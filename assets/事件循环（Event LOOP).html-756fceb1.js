import{_ as d,r,o as n,c as t,e as i,a,b as c,d as s}from"./app-aadb3056.js";const l={},h={href:"https://www.jianshu.com/p/57863d40cc7a",target:"_blank",rel:"noopener noreferrer"};function p(_,e){const o=r("ExternalLinkIcon");return n(),t("div",null,[e[1]||(e[1]=i('<h1 id="事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#事件循环-event-loop" aria-hidden="true">#</a> 事件循环（Event LOOP）</h1><p>JavaScript 是单线程的非阻塞式的脚本语言。</p><h2 id="_1-单线程" tabindex="-1"><a class="header-anchor" href="#_1-单线程" aria-hidden="true">#</a> 1. 单线程</h2><p>只有一个主线程来处理任务。</p><h2 id="_2-非阻塞" tabindex="-1"><a class="header-anchor" href="#_2-非阻塞" aria-hidden="true">#</a> 2. 非阻塞</h2><p>JS 引擎执行异步任务时，不会一直等待返回结果，主线程会挂起（pending）这个任务，继续执行其他任务。当异步任务返回结果时，JS 将异步任务的 callback 放到任务队列中。等到当前任务栈中的任务都执行完毕，处于闲置状态的主线程按照队列顺序将队首的 callback 函数加入到执行栈中，执行该函数的同步代码。如果又遇到异步任务，再将其回调函数加入到队列中——这就是事件循环机制。</p><p>JS 通常是非阻塞的，除了某些特殊情况，JS 会停止代码执行，例如：<code>alert</code>、<code>confirm</code>、<code>prompt</code>。</p><h2 id="_3-js-任务分类" tabindex="-1"><a class="header-anchor" href="#_3-js-任务分类" aria-hidden="true">#</a> 3. JS 任务分类</h2><h3 id="_3-1-宏任务" tabindex="-1"><a class="header-anchor" href="#_3-1-宏任务" aria-hidden="true">#</a> 3.1 宏任务</h3><p>时间粒度比较大，执行的时间间隔不能精确控制。常见的宏任务包括：</p><ul><li>script（外层同步代码）</li><li><code>setTimeout</code> 和 <code>setInterval</code></li><li>UI rendering/UI 事件</li><li><code>postMessage</code></li><li><code>MessageChannel</code></li><li><code>setImmediate</code>（Node.js）</li><li>I/O 操作（Node.js）</li></ul><h3 id="_3-2-微任务" tabindex="-1"><a class="header-anchor" href="#_3-2-微任务" aria-hidden="true">#</a> 3.2 微任务</h3><p>一个需要异步执行的函数，执行时机是在主函数结束之后，当前宏任务结束之前。常见的微任务包括：</p><ul><li><code>Promise.then</code></li><li><code>MutationObserver</code></li><li><code>Object.observe</code>（已废弃，被 <code>Proxy</code> 对象替代）</li><li><code>process.nextTick</code>（Node.js）</li></ul><p><strong>注意</strong>：<code>new Promise(...)</code> 中的代码是同步代码，会立即执行。只有 <code>then</code> 之后的代码才是异步执行的代码。</p><p><strong>说明</strong>：<code>process.nextTick()</code> 是 Node.js 中的一个 API，用于将一个回调函数添加到事件循环的下一轮迭代中执行。它的作用类似于 <code>setImmediate</code>，但优先级更高，会尽快执行。通常用于在当前事件循环结束后立即执行一些操作，而不需要等待下一轮事件循环。</p><h2 id="_4-执行顺序" tabindex="-1"><a class="header-anchor" href="#_4-执行顺序" aria-hidden="true">#</a> 4. 执行顺序</h2><p>同步任务 -&gt; 微任务 -&gt; 宏任务</p><h2 id="_5-案例" tabindex="-1"><a class="header-anchor" href="#_5-案例" aria-hidden="true">#</a> 5. 案例</h2>',19)),a("p",null,[a("a",h,[e[0]||(e[0]=c("案例链接")),s(o)])]),e[2]||(e[2]=a("hr",null,null,-1))])}const f=d(l,[["render",p],["__file","事件循环（Event LOOP).html.vue"]]);export{f as default};
